# [NOIP2004 普及组] 火星人 - 题解

简单地逛了逛题解区，发现大部分题解分为两种：

next_permutation
手写 next_permutation

于是，我为了不让题解区太单调，也为了拓宽大家的思维，就经过几分钟的努力，想出了一种与众不同的方法。
Updated on 2022.7.14: 添加 LaTeX\LaTeXLATE​X，增加变进制数加法的讲解。

变进制数

我们的目标是把全排列转化成一个变进制数，以方便我们进行加法。
对于第 iii 根手指，它有 n−i+1n-i+1n−i+1 种选择，根据位值原理，要想让每个数对应一个全排列，就要让这一位数是 n−i+1n-i+1n−i+1 进制的。
那么，整个过程分为三步：

将火星数变成变进制数
将变进制数加上 mmm
将变进制数变成火星数

我们来看一个实例：
将 1,4,5,2,31,4,5,2,31,4,5,2,3 变成变进制数：

首位 111 是 555 种选择 {1,2,3,4,5}\{1,2,3,4,5\}{1,2,3,4,5} 的第 111 种，故变为 000（从0开始）
次位 444 是 444 种选择 {2,3,4,5}\{2,3,4,5\}{2,3,4,5} 的第 333 种，故变为 222
中间位 555 是 333 种选择 {2,3,5}\{2,3,5\}{2,3,5} 的第 333 种，故变为 222
次低位 222 是 222 种选择 {2,3}\{2,3\}{2,3} 的第 111 种，故变为 000
末位 333 是 111 种选择 {3}\{3\}{3} 的第 111 种，故变为 000
最后，排列 1,4,5,2,31,4,5,2,31,4,5,2,3 变成了(02200)unknown(02200)_{unknown}(02200)unknown​

接下来给它加上 333 变成 (02203)(02203)(02203)，并处理进位：

末位是 111 进制的，进 333 得 (02230)(02230)(02230)。
次低位是 222 进制的，满 222 进一得 (02310)(02310)(02310)。
中间位是 333 进制的，满 333 进一得 (03010)(03010)(03010)。
次位是 444 进制的，3<43<43<4，不进位，得 (03010)unknown(03010)_{unknown}(03010)unknown​。

最后将 (03010)unknown(03010)_{unknown}(03010)unknown​ 变回火星数。

首位 000 表示这位应选择 {1,2,3,4,5}\{1,2,3,4,5\}{1,2,3,4,5} 的第 111 种，即 111
次位 333 表示这位应选择 {2,3,4,5}\{2,3,4,5\}{2,3,4,5} 的第 444 种（111 被选过了），即 555
中间位 000 表示这位应选择 {2,3,4}\{2,3,4\}{2,3,4} 的第 111 种，即 222
次低位 111 表示这位应选择 {3,4}\{3,4\}{3,4} 的第 222 种，即 444
末位 000 表示这位应选择 {3}\{3\}{3} 的第 111 种，即 333

所以本题答案为 14523 +3=+3=+3= 15243。
代码 373737 行，应该是除 STL 外较短的了。
#include<bits/stdc++.h>
using namespace std;
int a[10005];
bool used[10005]={0};
int m,n;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        int x=a[i];
        for(int j=1;j<=a[i];j++)
            x-=used[j];
        used[a[i]]=1;
        a[i]=x-1;
    }
    a[n]+=m;
    for(int i=n;i>0;i--)
    {
        a[i-1]+=a[i]/(n-i+1);
        a[i]%=n-i+1;
    }
    memset(used,0,sizeof(used));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=a[i];j++)
            if(used[j])
                a[i]++;
        cout<<a[i]+1<<" ";
        used[a[i]]=1;
    }
    return 0;
}


这篇题解是我较早时候发的，通过评论区我纠正了举个栗子那个部分的小问题。
现在我也通过评论区知道我这方法叫做康托展开。如果你想了解更多，可以看这篇博客.
 