# [USACO1.5] [IOI1994]数字三角形 Number Triangles - 题解

分析题干，发现从上面往下一步步走很麻烦，直接搜索肯定超时。所以，逆向求解。
看样例分析：
        7 
      3   8 
	8   1   0 
  2   7   4   4 
4   5   2   6   5

若从倒数第二排的‘2’开始走，只有2个选择，往左下方和右下方。
往左下方是‘4’，得到的最终值为6，往右下方是‘5’，得到的最终值是7.这时当然选择右下方。
我们就将‘2’改写成2+5=7。 再次考虑倒数第二排的7，
同理，应选择左下，得到最终值是12。还是将‘7’改写成5+7=12。
依次类推则倒数第二排变为：
7 12 10 10 

原数字三角形变为：
        7 
      3   8 
	8   1   0 
  7   12  10  10 
4   5    2    6   5

这时再考虑第三行第一个。有两种选择：左下和右下。
假设走左下方，由于这时左下的值已经是从左下开始走到底的最优值，我们不需要在选择下一步怎么走，直接加上左下的值即可。
同理，走右下时，直接加上右下的值即可。因为此时右下的值已经是从右下走到底的最优值，不需要选择了。
再比较走两条路的值，右边的值更大，选择右边的值。则第三行的第一个值更新为8+12=20。
以此类推，得到下面的数字三角形：
        7 
      3   8 
	20  13  10 
  7   12  10  10 
4   5    2    6   5

同理，更新第二排，有：
           7 
        23   21 
     20   13   10 
   7   12   10  10 
4    5    2    6    5 

最后一个了，有：
           30 
        23   21 
     20   13   10 
   7   12   10  10 
4    5    2    6    5 

起点的值保存了从起点到终点的最优值，也就是答案。详见代码：
include<iostream> 
include<cstdio> 
include<cmath> 
using namespace std;  
int n;  
int a[1000][1000];  
int main()  
{       
	scanf("%d",&n);  
	for(int i=0;i<n;i++)  
	for(int j=0;j<=i;j++)  
	scanf("%d",&a[i][j]);//以上输入  
	for(int i=n-2;i>=0;i--)   
	{  
 		for(int j=0;j<=i;j++)//for循环按顺序扫描除最后一排前的所有数  
		a[i][j]+=max(a[i+1][j],a[i+1][j+1]); 
        //从左下，右下中选取大的加到现在的位置上 
    } 
    cout<<a[0][0]<<endl; 
    return 0; 
 }

 