# [NOIP2000 普及组] 计算器的改良 - 题解

这道题思维难度和代码难度都不大，就是细节处理有点麻烦，需要判断一些特殊情况（比如 --0.0什么的）。那我就直接上代码思路了。

因为是一元一次方程，所以最终一定可以化成 kx+b=0kx+b=0kx+b=0 的形式，整理可得 x=−bkx=-\frac{b}{k}x=−kb​ ，为了减少变量数方便，将等号右边的多项式直接移到等式左边，即系数均乘 -1，可以用一个变量标记一下。

然后就是一连串的判断：

对于符号 ‘+’，‘-’，‘=’ 的处理

if(c=='-') {b+=now*f*x;x=0;f=-1;}
if(c=='+') {b+=now*f*x;x=0;f=1;}
if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;}

这里 b 为常数部分的值；now 表示相对等号的位置，左边为 1 ，右边为 -1；f 表示项的系数的正负性，x 则是项的系数。

读到加号，常数累加，系数清零，符号标记为正，减号同理。读到等号则需额外将 now 改为 -1。


关于数字的读入

if(c>='0'&&c<='9') {x=x*10+c-'0';}

若判定为数字则叠加当前项系数。


关于未知数的处理

if(c>='a'&&c<='z') {k+=now*f*x;x=0;a=c;}

若判定为小写字母，则将未知数的系数累加，项系数清零，并标记未知数名 a。   


至此，这一题就成功的解决挂掉了。因为(变量 r 的含义还没讲呢！)还有
特殊情况


要是遇到 +x , -x 这种情况怎么办？
那还不简单，系数为 0 就默认改为 1 就好了嘛。
if(c>='a'&&c<='z')
{
	x?k+=now*f*x:k+=now*f;
    x=0;a=c;
}

那如果是 +0x , -0x 这种毒瘤情况又怎么办？
这就需要引入一个新的变量 r 来标记是否有系数的读入。至于 r 的处理，只需要在读到数字时将 r 置为 1 ，读到其它字符都将 r 置为 0 就行了。
if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
if(c>='a'&&c<='z')
{
	if(r)
	{
		k+=now*f*x;x=0;
	}
	else k+=now*f;
	a=c;r=0;
}
if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}



遇到 −x=0-x=0−x=0 这种情况总是输出 -0.0 怎么办？
我就是这个原因死在了第五个点，看了题解才知道原来是因为 0 除以负数会被计算成 -0.0 。所以需要特判一下。


完整AC代码如下：
#include <iostream>
#include <cstdio>
using namespace std;
char c,a;//c用来读入,a是未知数名
int f=1,now=1,k,b,x;//f初始化为正，now初始为左，k、b、x意义如上
bool r;//用来判是否有数字读入
int main()
{
	while(cin>>c)//各种处理上面已经解释的很清楚了……（吧）
	{
		if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
		if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
		if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
		if(c>='a'&&c<='z')
		{
			if(r)
			{
				k+=now*f*x;x=0;
			}
			else k+=now*f;
			a=c;r=0;
		}
		if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
	}
	b+=now*f*x;//加上最后一项常数（若最后一项是未知数则会加0）
    double ans=double(-b*1.0/k);
	if(ans==-0.0) ans=0;//特判，将-0.0改为0
	printf("%c=%.3lf",a,ans);//保留三位小数输出
	return 0;
}

 