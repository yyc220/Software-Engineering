# 【模板】排序 - 题解

本题解/笔记专门讲述快速排序及其应用，比较适合新手学习和阅读，如果想了解其他做法请移步。

快速排序是 OI 中常用的算法。这篇题解/笔记将会详细地讲解快速排序的原理、实现过程，也会拓展 STL sort 函数的使用和快排复杂度及其证明。
快速排序的原理
我们设待排序的序列为一个长度为 nnn 的序列 aaa。快速排序的具体原理如下：
首先，在 aaa 中随机选择一个数 xxx，之后我们进行如下操作：

如果 n=0n=0n=0 或 n=1n=1n=1，此时根本无需排序，直接退出；
定义三个新的序列 b,c,db, c, db,c,d；
在 aaa 中随机选择一个数 xxx；
遍历整个序列 aaa，将比 xxx 小的放在 bbb 内，比 xxx 大的放在 ddd 内，和 xxx 相等的放在 ccc 内；
将 b,db, db,d 按如上过程继续排序。序列 ccc 中的数因为都相等所以不必排序。

说起来可能有点抽象，给大家举个例子：
我们定义一个未排序序列 a={3,2,4,1}a=\{3, 2, 4, 1\}a={3,2,4,1}。
我们从序列中选择第一个数 a1=3a_1=3a1​=3，根据上面的过程可知，b={2,1},c={3},d={4}b=\{2, 1\}, c=\{3\}, d=\{4\}b={2,1},c={3},d={4}。
此时因为 c,dc, dc,d 长度已经为 111，所以不必再排序；而同理，在序列 bbb 中，我们可以将两个数分为两个序列（相当于把它们交换位置），最终就可以完成排序。排序结果为 a={1,2,3,4}a=\{1, 2, 3, 4\}a={1,2,3,4}。

快速排序如何用 C++ 实现？
我们以 P1177 【模板】排序为例来讲解这一算法的实现过程。
普通自定义函数
首先，我们看完如上所示的实现方法与过程后，可以发现：实际上每一次的排序之后都会通过调用本身来继续排序，这明显就是递归的精髓。
确实，递归是快速排序的主要思想，通过递归，我们将一个完整的序列经过不断的分解来变成很多个小序列，直到只有一个或没有数为止。这种排序就是在不断的递归和分解当中来慢慢实现与完成排序。
这里，我们提供了这个函数的参考代码：
// 注：四个数组的下标均从 0 开始。
int randint(int l, int r){ // 生成在 [l, r] 之间的随机数
	return rand() % (r - l + 1) + l;
}
void qsort(int l, int r){ // l 为左端点，r 为右端点
	if(l >= r){ // 如果长度为 0 就返回
		return;
	}
   // 给大家讲解一下为什么此时可以不用判长度为 1 的序列：
   // 因为序列中的这个数在添加的过程中会自动被分到 c 数组中去，而 c 在之后是不用排序的，相当于什么都没做，当然也可以在这里判一下长度为 1 的情况，直接 return 就可以了
	int num = randint(l, r), ind1 = 0, ind2 = 0, ind3 = 0; // 随机选择一个数，并定义三个作为下标的变量来记录长度、存放数据
	for(int i = l;i <= r;i++){ // 将 a 中的数分别分到 b, c, d（如上所述）
		if(a[i] < a[num]){
			b[ind1++] = a[i];
		}
		else if(a[i] == a[num]){
			c[ind2++] = a[i];
		}
		else{
			d[ind3++] = a[i];
		}
	}
	for(int i = 0;i < ind1;i++){ // 将 b, c, d 中的数重新放回 a
		a[i + l] = b[i];
	}
	for(int i = 0;i < ind2;i++){
		a[i + ind1 + l] = c[i];
	}
	for(int i = 0;i < ind3;i++){
		a[i + ind1 + ind2 + l] = d[i];
	}
	qsort(l, l + ind1 - 1); // 继续排序原来的 b 和 d
	qsort(l + ind1 + ind2, r);
}

拓展：STL sort 函数的使用
除了如上的快排模板外，我们还可以使用 C++ algorithm 头文件中的 sort 函数来直接完成排序，时间复杂度均为 O(nlog⁡n)O(n\log n)O(nlogn)。其使用方法如下：
我们设我们排序的数组为 aaa，排序区间为 [l,r][l, r][l,r]，且从小到大排序。则调用方法为：
sort(a + l, a + r);、
注意，如果你想使用这个函数，你应该在头文件中加上 #include <algorithm> 或者 #include <bits/stdc++.h>（万能头文件）。
如果我们不想从小到大排序，而是想从大到小排序呢？那么我们就应该写一个比较函数（一般命名为 cmp）来改变排序方法。
例如我们想要把一个类型为 int 的数组从大到小排序，我们应该这么定义这个比较函数：
bool cmp(int a, int b){
	return a > b;
}

我们只需要定义两个与数组类型相同的变量作为参数，再返回两个数字的比较就可以了。
如果是从小到大排序，就用小于号连接两数；如果是从大到小排序，就用大于号连接两数，简记为：符号开口就代表大的在哪（大于号代表从大到小，小于号代表从小到大）。
写完这个函数，我们只需要在调用 sort 函数时在第三个参数写上函数名（例如 sort(a + l, a + r, cmp);）就可以了。
同样，结构体也可以用它排序。
例如我们定义一个结构体：
struct node{
	int x, y;
}c[1000];

此时，我们想这样对 ccc 排序：xxx 更大的在前，如果 xxx 相同则 yyy 更大的在前。
此时，我们可以这样写比较函数：
bool cmp(node a, node b){
	if(a.x != b.x){ // 如果两个 x 不等则以 x 的大小排序
		return a.x > b.x;
	}
	return a.y > b.y; // 否则以 y 的大小排序

注意：在结构体排序中，必须创建比较函数，否则会编译错误。

快速排序的复杂度
时间复杂度[1]^{[1]}[1]
快速排序最好情况下的时间复杂度为 O(nlog⁡n)O(n\log n)O(nlogn)，一般情况下的复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)，最坏时间复杂度为 O(n2)O(n^2)O(n2)。如下是其证明：
根据快速排序的实现过程和如上代码可以发现，每一次将原序列分为 333 个序列的过程的时间复杂度是 O(n)O(n)O(n)。
对于最优情况，当每一次随机选择的都是序列的中位数时，我们要排序的序列将被分成两个长度相差不多的两个序列。此时时间复杂度的递推式满足 T(n)=2T(n2)+O(n)=O(nlog⁡n)T(n)=2T(\frac{n}{2})+O(n)=O(n\log n)T(n)=2T(2n​)+O(n)=O(nlogn)，所以其最好情况为 O(nlog⁡n)O(n\log n)O(nlogn)；
对于最坏情况，当每一次选择的都是数列的最值（一个典型的例子就是数列已经有序），此时除了与选定的数相等的数以外，剩下的数仍然需要排序（一个序列为空，另一个包含了除与选定的数相等的数以外的所有数），此时的复杂度递推式为 T(n)=T(n−1)+n=O(n2)T(n)=T(n-1)+n=O(n^2)T(n)=T(n−1)+n=O(n2)，所以快速排序的最坏时间复杂度为 O(n2)O(n^2)O(n2)。
篇幅所限，这里无法提供一般情况下快排复杂度的证明，感兴趣的读者可以参考《算法导论》第 777 章第 444 节或查看 OI Wiki 中的相关内容。
空间复杂度
由于快速排序只需要一个序列来储存序列中的数（也可以再多加几个作为辅助），所以其空间复杂度为 O(n)O(n)O(n)。

引用
[1][1][1]：部分引用 OI Wiki 中有关快速排序-时间复杂度的内容。
 